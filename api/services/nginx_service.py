import os
import subprocess
from jinja2 import Template
from typing import Optional
from models import BuildLogModel, LogLevel, get_database

class NginxService:
    def __init__(self):
        self.config_path = os.getenv("NGINX_CONFIG_PATH", "/etc/nginx/sites-available")
        self.enabled_path = os.getenv("NGINX_ENABLED_PATH", "/etc/nginx/sites-enabled")
        self.base_domain = os.getenv("BASE_DOMAIN", "ao2395.com")
        self.mapping_file = "/etc/nginx/subdomain-map.conf"
        self.wildcard_config = "/etc/nginx/sites-available/wildcard-ao2395.com"
        
    async def log_operation(self, deployment_id: str, message: str, level: LogLevel = LogLevel.INFO):
        db = get_database()
        log_entry = BuildLogModel(
            deployment_id=deployment_id,
            message=message,
            log_level=level
        )
        await db.build_logs.insert_one(log_entry.dict(by_alias=True))
    
    async def generate_mapping_file(self, deployment_id: str) -> bool:
        """Generate the subdomain mapping file from database"""
        try:
            await self.log_operation(deployment_id, "Generating subdomain mapping file")
            
            db = get_database()
            deployments = await db.deployments.find({"status": "running"}).to_list(length=None)
            
            # Create mapping content
            mapping_content = "# Auto-generated by deployment system\n"
            mapping_content += "# Do not edit manually\n\n"
            
            for deployment in deployments:
                mapping_content += f"{deployment['subdomain']}.{self.base_domain} localhost:{deployment['port']};\n"
            
            # Write to temporary file first
            import tempfile
            with tempfile.NamedTemporaryFile(mode='w', delete=False, suffix='.conf') as temp_file:
                temp_file.write(mapping_content)
                temp_file_path = temp_file.name
            
            # Use sudo to move the file
            result = subprocess.run([
                'sudo', 'mv', temp_file_path, self.mapping_file
            ], capture_output=True, text=True)
            
            if result.returncode != 0:
                await self.log_operation(deployment_id, f"Failed to update mapping file: {result.stderr}", LogLevel.ERROR)
                return False
            
            await self.log_operation(deployment_id, f"Mapping file updated with {len(deployments)} deployments")
            return True
            
        except Exception as e:
            await self.log_operation(deployment_id, f"Failed to generate mapping file: {str(e)}", LogLevel.ERROR)
            return False
    
    def generate_wildcard_nginx_config(self) -> str:
        """Generate the wildcard nginx configuration"""
        config = f"""# Wildcard configuration for {self.base_domain}
# Load the mapping
map $host $backend {{
    include {self.mapping_file};
    default http://localhost:404;
}}

server {{
    listen 80;
    server_name *.{self.base_domain};
    
    # Handle Next.js static files
    location /_next/static/ {{
        proxy_pass $backend;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
        proxy_read_timeout 86400;
        proxy_buffering off;
        proxy_connect_timeout 60;
        proxy_send_timeout 60;
        
        # Cache static files
        expires 1y;
        add_header Cache-Control "public, immutable";
    }}
    
    # Handle all other requests
    location / {{
        proxy_pass $backend;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
        proxy_read_timeout 86400;
        proxy_buffering off;
        proxy_connect_timeout 60;
        proxy_send_timeout 60;
    }}
}}"""
        return config
    
    async def setup_wildcard_config(self, deployment_id: str) -> bool:
        """Setup the wildcard nginx configuration"""
        try:
            await self.log_operation(deployment_id, "Setting up wildcard nginx configuration")
            
            # Create wildcard config
            config_content = self.generate_wildcard_nginx_config()
            
            # Write to temporary file first
            import tempfile
            with tempfile.NamedTemporaryFile(mode='w', delete=False, suffix='.conf') as temp_file:
                temp_file.write(config_content)
                temp_file_path = temp_file.name
            
            # Use sudo to move the file
            result = subprocess.run([
                'sudo', 'mv', temp_file_path, self.wildcard_config
            ], capture_output=True, text=True)
            
            if result.returncode != 0:
                await self.log_operation(deployment_id, f"Failed to create wildcard config: {result.stderr}", LogLevel.ERROR)
                return False
            
            # Enable the wildcard site
            enabled_path = os.path.join(self.enabled_path, "wildcard-ao2395.com")
            result = subprocess.run([
                'sudo', 'ln', '-sf', self.wildcard_config, enabled_path
            ], capture_output=True, text=True)
            
            if result.returncode != 0:
                await self.log_operation(deployment_id, f"Failed to enable wildcard site: {result.stderr}", LogLevel.ERROR)
                return False
            
            await self.log_operation(deployment_id, "Wildcard nginx configuration setup complete")
            return True
            
        except Exception as e:
            await self.log_operation(deployment_id, f"Failed to setup wildcard config: {str(e)}", LogLevel.ERROR)
            return False
    
    async def create_config(self, subdomain: str, port: int, deployment_id: str) -> bool:
        """Update mapping file instead of creating individual configs"""
        try:
            await self.log_operation(deployment_id, f"Adding {subdomain} to nginx mapping")
            
            # Generate mapping file from database
            success = await self.generate_mapping_file(deployment_id)
            if not success:
                return False
            
            await self.log_operation(deployment_id, f"Added {subdomain}.{self.base_domain} -> localhost:{port}")
            return True
            
        except Exception as e:
            await self.log_operation(deployment_id, f"Failed to add to mapping: {str(e)}", LogLevel.ERROR)
            return False
    
    async def enable_site(self, subdomain: str, deployment_id: str) -> bool:
        """No longer needed with wildcard config"""
        return True
    
    async def reload_nginx(self, deployment_id: str) -> bool:
        try:
            await self.log_operation(deployment_id, "Reloading nginx configuration")
            
            result = subprocess.run(['sudo', 'nginx', '-t'], capture_output=True, text=True)
            if result.returncode != 0:
                await self.log_operation(deployment_id, f"Nginx config test failed: {result.stderr}", LogLevel.ERROR)
                return False
            
            result = subprocess.run(['sudo', 'systemctl', 'reload', 'nginx'], capture_output=True, text=True)
            if result.returncode != 0:
                await self.log_operation(deployment_id, f"Nginx reload failed: {result.stderr}", LogLevel.ERROR)
                return False
            
            await self.log_operation(deployment_id, "Nginx reloaded successfully")
            return True
            
        except Exception as e:
            await self.log_operation(deployment_id, f"Failed to reload nginx: {str(e)}", LogLevel.ERROR)
            return False
    
    async def remove_config(self, subdomain: str, deployment_id: Optional[str] = None) -> bool:
        """Remove subdomain from mapping file"""
        try:
            if deployment_id:
                await self.log_operation(deployment_id, f"Removing {subdomain} from nginx mapping")
            
            # Regenerate mapping file (this will exclude the deleted deployment)
            if deployment_id:
                success = await self.generate_mapping_file(deployment_id)
                if not success:
                    return False
            else:
                # For non-deployment operations, just regenerate the mapping
                db = get_database()
                deployments = await db.deployments.find({"status": "running"}).to_list(length=None)
                
                mapping_content = "# Auto-generated by deployment system\n"
                mapping_content += "# Do not edit manually\n\n"
                
                for deployment in deployments:
                    mapping_content += f"{deployment['subdomain']}.{self.base_domain} localhost:{deployment['port']};\n"
                
                # Write mapping file
                with open(self.mapping_file, 'w') as f:
                    f.write(mapping_content)
            
            if deployment_id:
                await self.log_operation(deployment_id, f"Removed {subdomain} from mapping")
            return True
            
        except Exception as e:
            if deployment_id:
                await self.log_operation(deployment_id, f"Failed to remove from mapping: {str(e)}", LogLevel.ERROR)
            else:
                print(f"Failed to remove from mapping: {e}")
            return False
    
    async def setup_deployment_nginx(self, subdomain: str, port: int, deployment_id: str) -> bool:
        try:
            # Ensure wildcard config exists
            if not os.path.exists(self.wildcard_config):
                success = await self.setup_wildcard_config(deployment_id)
                if not success:
                    return False
            
            # Add to mapping file
            success = await self.create_config(subdomain, port, deployment_id)
            if not success:
                return False
            
            # Reload nginx
            success = await self.reload_nginx(deployment_id)
            if not success:
                return False
            
            await self.log_operation(deployment_id, f"Nginx setup completed for {subdomain}.{self.base_domain}")
            return True
            
        except Exception as e:
            await self.log_operation(deployment_id, f"Nginx setup failed: {str(e)}", LogLevel.ERROR)
            return False